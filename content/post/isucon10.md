---
title: "ISUCON10予選に参加して敗北しました"
date: 2020-09-17T17:11:43+09:00
tags: ["isucon", "参加レポート"]
categories: ["tech"]
thumbnail: "images/tn.png??"
description: "ISUCON10予選に参加しましたが、太刀打ち出来ずに敗北しました。"
draft: false
---

@Rasino66 と2人で [ISUCON10](http://isucon.net/archives/54704557.html) の予選に参加してきました。  
残念ながら本戦に出場は出来ませんでしたが、学びが多い面白い問題でした。

Discordで通話しつつ画面を共有してやり取りしていましたが、これは普段から同じ手法で2人オンライン読書会してたりするので、  
特に困ることもなかったです。
コードの編集等は難しいことを考えずに直接サーバへSSHした上で、Vimで編集していました。  
言語はGoを選択しました。  

## 前半

最序盤はベンチマークが回せなかったので、事前に準備していた通りに以下を行いました。  
ここまでは練習通りに出来ていて良かったです。

- サーバに必要なものを入れる
    - pt-query-digest
    - kataribe
    - Vimの設定等
- MySQL, Nginxのログ周りを出力するように設定する
- マニュアルを読む

上記準備が終わった頃にはベンチマークが回せるようになっていたので、とりあえず初回のベンチマークを実行し、  
MySQLのCPU使用率が支配的であることを確認しました。  

pt-query-digestの結果から  
以下にインデックスを追加し、スコアが少し延びたことを確認しましたが、依然としてMySQLのCPU使用率が高いことを確認したため、ダメそうな箇所を改善し始めました。  

- estateテーブル
    - door_width
    - door_height
    - popularity
    - rent
- chairテーブル
    - price
    - stock
    - popularity

どうも以下のようなクエリが実行されたときにインデックスを使えておらず、  
詳しく見てみると popularity を DESC で ORDER BY, その後 id を ASCで ORDER BYしているのが駄目なようです。

```
mysql> explain SELECT * FROM estate WHERE rent >= 100000 AND rent < 150000 ORDER BY popularity DESC, id ASC LIMIT 25;
+----+-------------+--------+------------+------+---------------+------+---------+------+-------+----------+-----------------------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                       |
+----+-------------+--------+------------+------+---------------+------+---------+------+-------+----------+-----------------------------+
|  1 | SIMPLE      | estate | NULL       | ALL  | idx_rent      | NULL | NULL    | NULL | 29533 |    30.32 | Using where; Using filesort |
+----+-------------+--------+------------+------+---------------+------+---------+------+-------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)
```

以下のように 両方 DESC もしくは 両方 ASC であれば インデックスが効きます。  

```
mysql> explain SELECT * FROM estate WHERE rent >= 100000 AND rent < 150000 ORDER BY popularity DESC, id DESC LIMIT 25;
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | estate | NULL       | index | idx_rent      | idx_popularity | 4       | NULL |  270 |    30.32 | Using where |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain SELECT * FROM estate WHERE rent >= 100000 AND rent < 150000 ORDER BY popularity ASC, id ASC LIMIT 25;
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | estate | NULL       | index | idx_rent      | idx_popularity | 4       | NULL |  270 |    30.32 | Using where |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

どうにかする方法無いかと調べてみると、`Descending Indexes` というやつがあり、これを使えばインデックスを効かせられそうでした。  
ただ、`Descending Indexes` は MySQL8.0からのサポートのようで、MySQLをアップグレードする必要がありそうでした。  
MySQL8.0 に上げるとクエリキャッシュが無くなってスコア下がるんじゃ... という懸念があり、  
すんなりアップグレード出来るのかという不安もあったため、アップグレードは諦めました。  

## 後半

どうしようかね〜と話をしつつ、とりあえず出来るところからということでNginxでBotアクセスには503を返すように設定していました。  
この辺りからお腹が空いてご飯のことしか考えられなくなったため、Uber eatsでパスタを注文しました。  

id ASCの部分をMySQLではなく、アプリ側でなんとか出来ないか試しつつ、  
DBアクセスのほとんどがSELECTで、INSERTはそこまで多くない印象だったため、  
単純にレプリケーションして、参照先のDBをサーバ2台に分ければなんとかならないかなと甘いことを考えつつ試してみました。  

レプリケーションして、ベンチマークを回したところ、(おそらく)レプリケーション遅延により返す内容合っていないのかベンチマーク途中から点数がどんどん下がって行くことを確認しました。  
切り戻そうかと考えていましたが、そこでタイムアップになり終了しました。

## 振り返り

振り返ってみると、結局あまり出来たことが無いなという感じです。  
`ORDER BY popularity DESC, id ASC` の対策については ISUCON参加者のDiscordの感想を見ているとなるほど～と思うような解放があり、実力不足を感じました。  
来年は本戦に出れるように精進していきたいです。
